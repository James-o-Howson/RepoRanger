using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Quartz;
using RepoRanger.Application.Abstractions.Interfaces;
using RepoRanger.Application.Abstractions.Interfaces.Persistence;
using RepoRanger.BackgroundJobs.Abstractions;
using RepoRanger.BackgroundJobs.Abstractions.Options;

namespace RepoRanger.BackgroundJobs.Jobs;

[DisallowConcurrentExecution]
internal sealed class VulnerabilityDiscoveryJob : BaseJob<VulnerabilityDiscoveryJob>
{
    internal static readonly JobKey JobKey = new(nameof(VulnerabilityDiscoveryJob));
    
    private readonly ILogger<BaseJob<VulnerabilityDiscoveryJob>> _logger;
    private readonly IApplicationDbContext _applicationDbContext;
    private readonly IVulnerabilityService _vulnerabilityService;

    public VulnerabilityDiscoveryJob(ILogger<VulnerabilityDiscoveryJob> logger,
        IOptions<BackgroundJobOptions> options, IApplicationDbContext applicationDbContext, IVulnerabilityService vulnerabilityService) : base(logger, options)
    {
        _logger = logger;
        _applicationDbContext = applicationDbContext;
        _vulnerabilityService = vulnerabilityService;
    }

    protected override async Task ExecuteJobLogicAsync(IJobExecutionContext context)
    {
        var dependencyVersions = await _applicationDbContext.DependencyVersions
            .Include(v => v.Dependency)
            .Include(v => v.Sources)
            .Where(v => v.Sources.Any(s => s.Name == "NuGet"))
            .ToListAsync(context.CancellationToken);

        foreach (var version in dependencyVersions)
        {
            var result = await _vulnerabilityService.QueryVulnerabilitiesAsync(version, context.CancellationToken);
        }
    }
}