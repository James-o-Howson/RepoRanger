using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Quartz;
using RepoRanger.Application.Abstractions.Interfaces;
using RepoRanger.Application.Abstractions.Interfaces.Persistence;
using RepoRanger.Application.Contracts.Vulnerabilities.External.Request;
using RepoRanger.Application.Contracts.Vulnerabilities.External.Response;
using RepoRanger.BackgroundJobs.Abstractions;
using RepoRanger.BackgroundJobs.Abstractions.Options;
using RepoRanger.Domain.Dependencies;
using RepoRanger.Domain.Dependencies.Entities;

namespace RepoRanger.BackgroundJobs.Jobs;

[DisallowConcurrentExecution]
internal sealed class VulnerabilityDiscoveryJob : BaseJob<VulnerabilityDiscoveryJob>
{
    internal static readonly JobKey JobKey = new(nameof(VulnerabilityDiscoveryJob));
    
    private readonly ILogger<BaseJob<VulnerabilityDiscoveryJob>> _logger;
    private readonly IApplicationDbContext _applicationDbContext;
    private readonly IExternalVulnerabilityService _externalVulnerabilityService;

    public VulnerabilityDiscoveryJob(ILogger<VulnerabilityDiscoveryJob> logger,
        IOptions<BackgroundJobOptions> options, IApplicationDbContext applicationDbContext, IExternalVulnerabilityService externalVulnerabilityService) : base(logger, options)
    {
        _logger = logger;
        _applicationDbContext = applicationDbContext;
        _externalVulnerabilityService = externalVulnerabilityService;
    }

    protected override async Task ExecuteJobLogicAsync(IJobExecutionContext context)
    {
        var cancellationToken = context.CancellationToken;
        var dependencies = await GetPossiblyVulnerableDependenciesAsync(cancellationToken);

        foreach (var dependency in dependencies)
        {
            var query = ToExternalVulnerabilityBatchQuery(dependency);
            
            var response = await _externalVulnerabilityService.BatchQueryAffectedAsync(query, cancellationToken);
            AnalyseResultsAsync(dependency, query, response, cancellationToken);
        }
        
        await _applicationDbContext.SaveChangesAsync(cancellationToken);
    }

    private static void AnalyseResultsAsync(Dependency dependency, ExternalVulnerabilityBatchQuery query, ExternalVulnerabilitiesBatchResponse response, CancellationToken cancellationToken)
    {
        if(query.Packages.Count != response.OsvIds.Count) 
            throw new ApplicationException("Unable to Analyse Batch Vulnerabilities Query: Package count mismatch");

        for (var i = 0; i < response.OsvIds.Count; i++)
        {
            var osvId = response.OsvIds.ElementAt(i);
            var package = query.Packages.ElementAt(i);

            dependency.AddVulnerability(osvId, package.DependencyVersionValue, package.Ecosystem);
        }
    }

    private static ExternalVulnerabilityBatchQuery ToExternalVulnerabilityBatchQuery(Dependency dependency) =>
        new()
        {
            Packages = dependency.Versions.
                Select(ToExternalVulnerabilityQueries).
                SelectMany(q => q).
                ToList()
        };

    private static IEnumerable<ExternalVulnerabilityQuery> ToExternalVulnerabilityQueries(DependencyVersion version) =>
        version.Sources.Select(s => new ExternalVulnerabilityQuery
        {
            Name = version.Dependency.Name,
            Ecosystem = s.Name,
            DependencyVersionValue = version.Value ?? string.Empty
        });

    private async Task<List<Dependency>> GetPossiblyVulnerableDependenciesAsync(CancellationToken contextCancellationToken) =>
        await _applicationDbContext.Dependencies
            .Include(v => v.Versions)
            .ThenInclude(v => v.Sources)
            .Where(d => d.Versions.SelectMany(v => v.Sources).Any(s => s.Name == "NuGet" || s.Name == "npm"))
            .AsNoTracking()
            .ToListAsync(contextCancellationToken);
}